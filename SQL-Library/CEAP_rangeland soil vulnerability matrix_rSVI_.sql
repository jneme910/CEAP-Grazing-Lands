SET STATISTICS IO ON 

USE sdmONLINE
go

DROP TABLE IF EXISTS #map;
DROP TABLE IF EXISTS #water
DROP TABLE IF EXISTS #water2
DROP TABLE IF EXISTS #comp_main
DROP TABLE IF EXISTS #horizon
DROP TABLE IF EXISTS #surface
DROP TABLE IF EXISTS #surface_tex
DROP TABLE IF EXISTS #surface_tex2
DROP TABLE IF EXISTS #surface_tex3
DROP TABLE IF EXISTS #surface_tex4
DROP TABLE IF EXISTS #surface_final
DROP TABLE IF EXISTS #fragment 
DROP TABLE IF EXISTS #fragment2
DROP TABLE IF EXISTS #diag
DROP TABLE IF EXISTS #d
DROP TABLE IF EXISTS #r
DROP TABLE IF EXISTS #rest_pivot_table
DROP TABLE IF EXISTS #rest
DROP TABLE IF EXISTS #frag_pivot_table
DROP TABLE IF EXISTS #frag
DROP TABLE IF EXISTS #surface_final2
DROP TABLE IF EXISTS #surface_final3
DROP TABLE IF EXISTS #spd
DROP TABLE IF EXISTS #acpf
DROP TABLE IF EXISTS #aws
DROP TABLE IF EXISTS #aws150

--Define the area
DECLARE @area VARCHAR(20);
DECLARE @area_type INT ;
DECLARE @domc INT ;
declare @cokey int = -1;
-- Soil Data Access
/*~DeclareChar(@area,20)~  -- Used for Soil Data Access
~DeclareINT(@area_type)~ */

-- End soil data access
SELECT @area= 'WI001'; --Enter State Abbreviation or Soil Survey Area i.e. WI or WI025
SELECT @domc = 0; --Enter 1 for dominant component else -1




------------------------------------------------------------------------------------
SELECT @area_type = LEN (@area); --determines number of characters of area 2-State, 5- Soil Survey Area
--creates the temp table for map unit and legend
CREATE TABLE #map
   ( areaname VARCHAR (255), 
    areasymbol VARCHAR (20),
    musym VARCHAR (20), 
	mukey INT, 
	muname VARCHAR (255), 
	datestamp VARCHAR(32), 
	major_mu_pct_sum SMALLINT)


--Queries the map unit and legend
--Link Main
INSERT INTO #map (areaname, areasymbol, musym, mapunit.mukey, muname, datestamp, major_mu_pct_sum)
SELECT legend.areaname, legend.areasymbol, musym, mapunit.mukey, muname, CONCAT ([SC].[areasymbol] , ' ' , FORMAT ( [SC].[saverest], 'dd-MM-yy')) AS datestamp, 
(SELECT SUM (CCO.comppct_r)
FROM mapunit AS MM2
INNER JOIN component AS CCO ON CCO.mukey = MM2.mukey AND mapunit.mukey = MM2.mukey --AND majcompflag = 'Yes'
) AS  major_mu_pct_sum
FROM (legend 
INNER JOIN mapunit ON legend.lkey=mapunit.lkey
AND areasymbol <> 'US'
--AND  CASE WHEN @area_type = 2 THEN LEFT (areasymbol, 2) ELSE areasymbol END = @area
) 
INNER JOIN sacatalog SC ON legend.areasymbol = SC.areasymbol


------------------------------------------------------------------------------------
---Queries the major components 

CREATE TABLE #comp_main ( mukey INT , compname VARCHAR (255), cokey INT, comppct_r  SMALLINT, 
 slope_r REAL , hydgrp VARCHAR (255), sum_fragcov_low REAL, sum_fragcov_rv REAL , sum_fragcov_high REAL, major_mu_pct_sum SMALLINT, adj_comp_pct REAL, mlra_sym VARCHAR (100), dom_key INT, ecositeid VARCHAR (254), ecositename VARCHAR (254) )

--TRUNCATE TABLE #comp_main
INSERT INTO #comp_main (mukey, compname, cokey, comppct_r ,

slope_r, hydgrp,  sum_fragcov_low, sum_fragcov_rv, sum_fragcov_high, major_mu_pct_sum, adj_comp_pct,  mlra_sym, dom_key, ecositeid, ecositename)
SELECT  map.mukey, compname, c.cokey, comppct_r ,

slope_r, hydgrp,

 (SELECT ROUND (SUM (sfragcov_l),2)
FROM component AS c2
INNER JOIN cosurffrags AS cosf ON cosf.cokey=c2.cokey AND c2.cokey=c.cokey GROUP BY c2.cokey)AS sum_fragcov_low,
 (SELECT ROUND (SUM (sfragcov_r),2)
FROM component AS c2
INNER JOIN cosurffrags AS cosf ON cosf.cokey=c2.cokey AND c2.cokey=c.cokey GROUP BY c2.cokey)AS sum_fragcov_rv,
(SELECT ROUND (SUM (sfragcov_h),2)
FROM component AS c2
INNER JOIN cosurffrags AS cosf ON cosf.cokey=c2.cokey AND c2.cokey=c.cokey GROUP BY c2.cokey)AS sum_fragcov_high,
major_mu_pct_sum, LEFT (ROUND ((1.0 * comppct_r / NULLIF(major_mu_pct_sum, 0)),2), 4) AS adj_comp_pct,

(SELECT DISTINCT SUBSTRING(  (  SELECT ( '; ' + lao.areasymbol)
FROM mapunit AS m
INNER JOIN muaoverlap AS mua ON mua.mukey=m.mukey 
INNER JOIN laoverlap AS lao ON mua.lareaovkey = lao.lareaovkey AND lao.areatypename='mlra'   
INNER JOIN component AS c9 ON c9.mukey=m.mukey
AND c.cokey=c9.cokey
ORDER BY lao.areasymbol ASC 
FOR XML PATH('') ), 3, 1000) )as [mlra_sym],
(SELECT TOP 1 c1.cokey FROM component AS c1 
INNER JOIN mapunit AS mu1 ON c1.mukey=mu1.mukey AND c1.mukey=map.mukey 
 ORDER BY c1.comppct_r DESC, CASE WHEN LEFT (muname, 3) = LEFT (compname, 3) THEN 1 ELSE 2 END ASC, c1.cokey  ) AS dom_key,

(SELECT TOP 1 coecoclass.ecoclassid FROM component INNER JOIN coecoclass on component.cokey = 
coecoclass.cokey AND coecoclass.cokey = c.cokey and coecoclass.ecoclassref like 'Ecological Site Description Database' order by ecoclassid) as ecositeID,
(SELECT TOP 1 coecoclass.ecoclassname 
FROM component INNER JOIN coecoclass on component.cokey = 
coecoclass.cokey AND coecoclass.cokey = c.cokey and coecoclass.ecoclassref like 'Ecological Site Description Database' order by ecoclassid) as ecositename

FROM #map AS map
INNER JOIN component AS c ON c.mukey=map.mukey --AND majcompflag = 'Yes'
-----------Dominant Comoonent
/*IF  @domc =1
begin      -- Assign value when using Dominant Component
    SELECT  @cokey = 
(SELECT TOP 1 c1.cokey FROM component AS c1 
INNER JOIN mapunit AS mu1 ON c1.mukey=mu1.mukey --AND mu1.mukey=map.mukey 
 ORDER BY c1.comppct_r DESC, CASE WHEN LEFT (muname, 3) = LEFT (compname, 3) THEN 1 ELSE 2 END ASC, c1.cokey  ) 
end -- [end of] Assign value when using Dominant Component
 */
 ----------End Dominant Comoonent
;

--SELECT @cokey
--Queries the all horizons and aggregates to 1 value based on different conditions

--link
CREATE TABLE #horizon
   ( mukey INT , compname VARCHAR (255), cokey INT, 
   maxcaco3_0_2cm SMALLINT, hzdept_r SMALLINT, hzdepb_r SMALLINT, awc_r REAL, chkey INT,  hzname VARCHAR (40))

--TRUNCATE TABLE #horizon
INSERT INTO #horizon ( mukey, compname, cokey,  
 maxcaco3_0_2cm,  hzdept_r, hzdepb_r , awc_r, chkey, hzname ) 
SELECT DISTINCT mukey, compname, #comp_main.cokey, 

(Select  MAX(ec_r) FROM component AS c INNER JOIN chorizon AS ch ON ch.cokey=c.cokey AND  hzdept_r < 2 and ch.cokey= #comp_main.cokey) as maxec_0_2cm,

hzdept_r, hzdepb_r , awc_r, chkey, hzname
FROM #comp_main
INNER JOIN chorizon ON chorizon.cokey=#comp_main.cokey 


------------------------------------------------------------------------------------
--Queries surface mineral horizon, eliminates duff layer but keeps wet organics -- Surface Mineralogy (separating Organic from Mineral)
--Link
CREATE TABLE #surface(cokey INT, chkey  INT, compname VARCHAR (255), hzname VARCHAR (40), hzdept_r SMALLINT, hzdepb_r SMALLINT, texture VARCHAR (250) , mineral_des VARCHAR (10), om_r REAL ,  surface_mineral VARCHAR(250), awc_r REAL, kwfact VARCHAR (254), kffact VARCHAR (254))

 INSERT INTO #surface(cokey , chkey  , compname, hzname , hzdept_r , hzdepb_r , texture, mineral_des, om_r, surface_mineral, awc_r, kwfact, kffact)
SELECT 
 #comp_main.cokey, chorizon.chkey, compname, hzname, hzdept_r, hzdepb_r, texture, 
 CASE WHEN desgnmaster LIKE '%h%' THEN 'H horizon'
 WHEN desgnmaster LIKE '%O%' THEN 'Organic' 
 WHEN  desgnmaster NOT LIKE '%O%' THEN 'Mineral' ELSE 'NA' END AS mineral_des, 
CAST (ISNULL (om_r, 0) AS decimal (5,2))AS om_r,
CASE WHEN ((claytotal_r) IS NOT NULL  AND (om_r) IS NOT NULL AND om_r >= 18*1.724 and claytotal_r >= 60) THEN 'Yes'
WHEN ((claytotal_r) IS NOT NULL  AND (om_r) IS NOT NULL AND (om_r >=(12 +(claytotal_r*0.1))*1.724) AND claytotal_r < 60) THEN 'Yes'
WHEN  (om_r >= 20*1.724 AND  (claytotal_r)  IS NOT NULL AND (om_r) IS NOT NULL) THEN 'Yes' 
ELSE 'No' END AS surface_mineral,  awc_r, kwfact, kffact
FROM #comp_main  
INNER JOIN(chorizon INNER JOIN chtexturegrp ON chorizon.chkey = chtexturegrp.chkey) ON #comp_main.cokey = chorizon.cokey
AND (((chorizon.hzdept_r)=(SELECT Min(chorizon.hzdept_r) AS MinOfhzdept_r
FROM chorizon INNER JOIN chtexturegrp ON chorizon.chkey = chtexturegrp.chkey
AND chtexturegrp.texture Not In ('SPM','HPM', 'MPM') 
AND chtexturegrp.rvindicator='Yes' AND #comp_main.cokey = chorizon.cokey ))AND ((chtexturegrp.rvindicator)='Yes'))
ORDER BY comppct_r DESC, cokey,  hzdept_r, hzdepb_r



------------------------------------------------------------------------------------
---Soil Surface Texture Class by Thickness (not depth)
---Eliminates Duff layer at the end and aggregates texture grouping
CREATE TABLE #surface_tex (cokey INT, chkey  INT, compname VARCHAR (250), hzname VARCHAR (20), hzdept_r SMALLINT, hzdepb_r SMALLINT, texture VARCHAR (30) ,  tex_modifier VARCHAR (255), tex VARCHAR (255), tex_in_lieu VARCHAR (255),  row_num INT, text_grouping VARCHAR (255), om_r SMALLINT)

 INSERT INTO #surface_tex (cokey, chkey, compname, hzname, hzdept_r, hzdepb_r, texture, tex_modifier, tex, tex_in_lieu, row_num, text_grouping, om_r ) 

 SELECT 
 #comp_main.cokey, chorizon.chkey, compname, hzname, hzdept_r, hzdepb_r, texture, 

(SELECT TOP 1 [ChoiceName] FROM chtexture AS cht, MetadataDomainMaster dm, MetadataDomainDetail dd, chtexturemod AS chtm WHERE  chtm.chtkey=cht.chtkey AND chtexturegrp.chtgkey=cht.chtgkey and texmod = ChoiceLabel and DomainName = 'texture_modifier' AND 
dm.DomainID=dd.DomainID ORDER BY choicesequence DESC) AS  tex_modifier,

(SELECT TOP 1 [ChoiceName] FROM chtexture AS cht, MetadataDomainMaster dm, MetadataDomainDetail dd WHERE chtexturegrp.chtgkey=cht.chtgkey and texcl = ChoiceLabel and DomainName = 'texture_class' AND 
dm.DomainID=dd.DomainID ORDER BY choicesequence DESC) AS  tex,

(SELECT TOP 1 [ChoiceName] FROM chtexture AS cht, MetadataDomainMaster dm, MetadataDomainDetail dd WHERE chtexturegrp.chtgkey=cht.chtgkey and lieutex = ChoiceLabel and DomainName = 'terms_used_in_lieu_of_texture' AND 
dm.DomainID=dd.DomainID ORDER BY choicesequence DESC) AS  tex_in_lieu,

 row_number() over (PARTITION BY #comp_main.cokey order by hzdept_r ASC ) as row_num, 

 CASE WHEN stratextsflag = 'Yes' THEN 'stratified'
 WHEN desgnmaster = 'O' THEN 'organic' END AS text_grouping,  om_r 
FROM #comp_main 
INNER JOIN(chorizon INNER JOIN chtexturegrp ON chorizon.chkey = chtexturegrp.chkey AND chtexturegrp.rvindicator='Yes') ON #comp_main.cokey = chorizon.cokey


-- surface tex 2 table
CREATE TABLE #surface_tex2 (cokey INT, chkey  INT, compname VARCHAR (255), hzname VARCHAR (20), hzdept_r SMALLINT, hzdepb_r SMALLINT, texture VARCHAR (30) ,  tex_modifier VARCHAR (254), tex VARCHAR (254), tex_in_lieu VARCHAR (254),  row_num INT, text_grouping VARCHAR (255), texture_grouping VARCHAR (255))

 INSERT INTO #surface_tex2 (cokey, chkey, compname, hzname, hzdept_r, hzdepb_r, texture, tex_modifier, tex, tex_in_lieu, row_num, text_grouping, texture_grouping) 

SELECT cokey, chkey, compname, hzname, hzdept_r, hzdepb_r, texture, tex_modifier, tex, tex_in_lieu, row_num, text_grouping, 

CASE WHEN text_grouping = 'organic'  THEN 'organic' 
WHEN text_grouping =  'stratified' THEN 'stratified'
WHEN tex_modifier IN ('ASHY', 'HYDR', 'MEDL') THEN 'volcanic modifier'
WHEN tex_modifier IN ('GS', 'HB', 'MS', 'WD') THEN 'organic soil material modifier'
WHEN tex_modifier IN ('HO', 'MK', 'PT') THEN 'highly organic mineral material modifier'
WHEN tex_modifier IN ('COP', 'DIA', 'MR') THEN 'limnic material modifier'
WHEN tex_modifier IN ('ART', 'ARTV', 'ARTVX') THEN 'anthropogenic material modifier'
WHEN tex_modifier = 'CEM' THEN 'cemented material modifier'
WHEN tex_modifier = 'GYP' THEN 'gypsiferous material modifier'
WHEN tex_modifier = 'PF' THEN 'permanently frozen material modifier'
WHEN tex = 'COS' THEN 'coarse textured'
WHEN tex = 'S'  THEN 'coarse textured'
WHEN tex = 'FS' THEN 'coarse textured'
WHEN tex = 'VFS' THEN 'coarse textured'
WHEN tex = 'LCOS' THEN 'coarse textured'
WHEN tex ='LS' THEN 'coarse textured'
WHEN tex = 'LFS' THEN 'coarse textured'
WHEN tex = 'LVFS'THEN 'coarse textured'
WHEN tex = 'COSL' THEN 'moderately coarse textured'
WHEN tex = 'SL' THEN 'moderately coarse textured'
WHEN tex = 'FSL' THEN 'moderately coarse textured'
WHEN tex = 'VFSL' THEN 'medium textured' 
WHEN tex = 'L' THEN 'medium textured' 
WHEN tex = 'SIL' THEN 'medium textured' 
WHEN tex = 'SI'  THEN 'medium textured' 
WHEN tex = 'CL'  THEN 'moderately fine textured'
WHEN tex = 'SCL' THEN 'moderately fine textured'
WHEN tex = 'SICL' THEN 'moderately fine textured'
WHEN tex = 'SC'  THEN  'fine textured' 
WHEN tex = 'SIC' THEN  'fine textured' 
WHEN tex = 'C' THEN  'fine textured' END AS texture_grouping
FROM #surface_tex


------------------------------------------------------------------------------------
---Surface Text 
CREATE TABLE #surface_tex3 (cokey INT, chkey INT, compname VARCHAR (255),  tex_modifier VARCHAR (254), tex_in_lieu VARCHAR (254),   texture_grouping VARCHAR (254),  hzname VARCHAR (12), hzdept_r SMALLINT, hzdepb_r SMALLINT,   min_top_depth SMALLINT, prev_texture_grouping VARCHAR (254), prev_bottom_depth SMALLINT , row_num INT)
INSERT INTO #surface_tex3 (cokey, chkey, compname, tex_modifier, tex_in_lieu, texture_grouping,	hzname,  hzdept_r, hzdepb_r,  min_top_depth ,	   prev_texture_grouping,   prev_bottom_depth, row_num  ) 

SELECT 
cokey, 
chkey,
compname, 
tex_modifier,  
tex_in_lieu, 
texture_grouping, 
 
hzname,  
hzdept_r, 
hzdepb_r, --tex,  
MIN(hzdept_r) over(partition by   cokey, texture_grouping order by hzdept_r ASC ROWS UNBOUNDED PRECEDING) as min_top_depth, 
  ISNULL (LAG(texture_grouping) OVER(PARTITION BY cokey ORDER BY hzdept_r ASC ),texture_grouping)  as prev_texture_grouping,
  ISNULL (LAG(hzdepb_r) OVER(PARTITION BY cokey ORDER BY hzdept_r ASC), hzdept_r) as prev_bottom_depth,
 ROW_NUMBER() OVER(PARTITION BY cokey, texture_grouping ORDER BY hzdept_r ASC ) AS row_num
 FROM #surface_tex2  AS s1
WHERE CASE 
WHEN tex_in_lieu = 'spm' THEN 1
WHEN tex_in_lieu = 'hpm' THEN 1
WHEN tex_in_lieu = 'mpm' THEN 1
WHEN tex_in_lieu IS NULL THEN 2 ELSE 2 END = 2
ORDER BY cokey,  hzdept_r , hzdepb_r,  chkey;


---with — recursive common table expression - CTE (common table expression)
WITH #surface_tex4  AS (SELECT cokey, chkey, compname, tex_modifier, tex_in_lieu, texture_grouping,	   hzname,  hzdept_r, hzdepb_r,  
min_top_depth , prev_texture_grouping,   prev_bottom_depth,  row_num  From #surface_tex3 WHERE 
 prev_bottom_depth=hzdept_r AND prev_texture_grouping=texture_grouping)


 ---Final Surface Texture grouping
 --link
 SELECT DISTINCT cokey,  compname, 
 SUBSTRING(  (  SELECT ( ', ' + tex_modifier)
FROM #surface_tex4 AS  st2   
WHERE st1.cokey = st2.cokey
GROUP BY cokey, tex_modifier
ORDER BY st1.cokey, st2.cokey
FOR XML PATH('') ), 3, 1000) as tex_modifier,
 
 
  tex_in_lieu, texture_grouping,	
  min_top_depth ,  MAX(hzdepb_r) over(partition by cokey, texture_grouping) as max_bottom_depth
 INTO #surface_final
 FROM #surface_tex4 AS st1
 GROUP BY  cokey,  compname, tex_modifier, tex_in_lieu, texture_grouping,	
  min_top_depth,hzdepb_r 
  ORDER BY cokey, min_top_depth ASC 

 SELECT cokey,	compname,	tex_modifier,	tex_in_lieu,	texture_grouping,		min_top_depth,	max_bottom_depth, ROW_NUMBER() OVER(PARTITION BY cokey ORDER BY min_top_depth ASC ) AS row_num 
 INTO #surface_final2
 FROM #surface_final
 ORDER BY cokey, min_top_depth ASC 

 SELECT cokey,	compname,	tex_modifier,	tex_in_lieu,	texture_grouping,		min_top_depth,	max_bottom_depth, row_num 
INTO #surface_final3
FROM  #surface_final2
WHERE row_num = 1 


--Final
SELECT DISTINCT 
#map.areaname, #map.areasymbol, #map.musym, #map.mukey, #map.muname, --#map
#comp_main.compname, #comp_main.cokey, #comp_main.comppct_r , mlra_sym, #horizon.maxcaco3_0_2cm,
hydgrp,
texture_grouping,
--texture,
 tex_modifier,  tex_in_lieu, om_r, 
#comp_main.slope_r,
sum_fragcov_low, sum_fragcov_rv, sum_fragcov_high,  adj_comp_pct,
CASE WHEN dom_key = #comp_main.cokey THEN 'Yes' ELSE 'No' END AS dom_comp_flag,
#surface.texture AS surf_texture,kwfact AS surf_kwfact, kffact AS surf_kffact,ecositeid, ecositename,
#map.datestamp
FROM #map
INNER JOIN #comp_main ON #comp_main.mukey=#map.mukey
LEFT OUTER JOIN #horizon ON #horizon.cokey=#comp_main.cokey
LEFT OUTER JOIN #surface ON #surface.cokey=#comp_main.cokey
LEFT OUTER JOIN #surface_final3 ON #surface_final3.cokey=#comp_main.cokey
GROUP BY 
#map.areaname, #map.areasymbol, #map.musym, #map.mukey, #map.muname, --#map
#comp_main.compname, #comp_main.cokey, #comp_main.comppct_r , mlra_sym, #horizon.maxcaco3_0_2cm,ecositeid, ecositename,
hydgrp,
texture_grouping,
--texture,
 tex_modifier,  tex_in_lieu,
#comp_main.slope_r,
sum_fragcov_low, sum_fragcov_rv, sum_fragcov_high,  adj_comp_pct,
#surface.texture,dom_key,
#map.datestamp, om_r, kwfact , kffact





DROP TABLE IF EXISTS #map;
DROP TABLE IF EXISTS #water
DROP TABLE IF EXISTS #water2
DROP TABLE IF EXISTS #comp_main
DROP TABLE IF EXISTS #horizon
DROP TABLE IF EXISTS #surface
DROP TABLE IF EXISTS #surface_tex
DROP TABLE IF EXISTS #surface_tex2
DROP TABLE IF EXISTS #surface_tex3
DROP TABLE IF EXISTS #surface_tex4
DROP TABLE IF EXISTS #surface_final
DROP TABLE IF EXISTS #fragment 
DROP TABLE IF EXISTS #fragment2
DROP TABLE IF EXISTS #diag
DROP TABLE IF EXISTS #d
DROP TABLE IF EXISTS #r
DROP TABLE IF EXISTS #rest_pivot_table
DROP TABLE IF EXISTS #rest
DROP TABLE IF EXISTS #frag_pivot_table
DROP TABLE IF EXISTS #frag
DROP TABLE IF EXISTS #surface_final2
DROP TABLE IF EXISTS #surface_final3
DROP TABLE IF EXISTS #spd
DROP TABLE IF EXISTS #acpf
DROP TABLE IF EXISTS #aws
DROP TABLE IF EXISTS #aws150